interface ObjectMap<K, V> {
    [key : K] : V
}

interface CallbackFunction<V, R> {
    (...value : any) : void
    (...value : V) : void
    (...value : V) : R
}



// library declaration (just things i really need)
declare namespace p5 {
    interface Vector {
        x : number, y : number, z : number
    }

    interface Event {
        keyPressed(code : number) : void
        mousePressed(btn : number) : void
    }


    declare class Canvas {
        width : number
        height : number
    }
}

declare namespace multis {
    declare type opcode = string;

    interface BaseEvent {
        start(interp : multis.Interpreter, pos : p5.Vector)
        step(state : multis.State)
        end()
    }

    interface ContextFunction<T> {
        (object : T) : void
    }

    interface ModiferFunction {
        (modifier : any) : void
        (modifier : any, operator : any) : void
    }

    declare class ContainerBase {
        constructor(interpreter : Interpreter)
    }

    declare class Container extends ContainerBase {
        state? : State | State[]
        suppress : boolean
        
        store(state : State) : void
        each(fn : CallbackFunction<State>) : void
        empty() : void

        suppress() : void
    }
    
    declare class Events {
        events : ObjectMap<string, CallbackFunction>
        data? : Container
        // mods : any[]
        // ops : any


        reset()  : void
        opt(xy : number, name : opcode) : void
        use(data : Container)
        used() : boolean
        
        emit(name : string, args : any[]) : boolean
        on(name : string, callback : CallbackFunction) : void
    }

    declare class Event implements BaseEvent {
        // modifiers : ObjectMap<number, any>
        requirements : Array<opcode|opcode[]>
        storage? : any // this is always any because this is acctually generated by a fn
        // events? : any // --> only required for the wrapping ability

        wrap(events : Events, context : ContextFunction<Event>) : void
        
        start(interp : multis.Interpreter, pos : p5.Vector)
        step(state : multis.State)
        end()


        useModifiers(position : p5.Vector, interpreter : multis.Interpreter, modifiers : Array<any>) : void
        modifier(offsetx : number, offsety : number, interpreter : multis.Interpreter, 
            modifiers : Array<any>, position : p5.Vector) : void

        mod(name : opcode, fn : ModiferFunction, fakeop? : boolean) : Event
        req(requirements : opcode|opcode[]) : Event
        use(cb) : void

        // idk ???
        get stores() : any
        get store() : any
    }

    declare namespace ops {
        declare function op(name : opcode, event? : any) : Event;
    }


    declare class State {
        value : number

        position : p5.Vector
        velocity : p5.Vector
        readonly preVel : p5.Vector

        frozen : boolean

        parent : Interpreter
        universe : Universe

        constructor(position : p5.Vector, velocity : p5.Vector, interpreter : Interpreter, value? : number)


        vel(velocity : p5.Vector) : void
        teleport(position : p5.Vector) : void

        freeze() : void
        unfreeze() : void
        destroy() : void

        
        // specific_unchecked() : boolean // --> this function should not be used
        // apply_unchecked() : void // --> this function should not be used
        apply() : void
        
        update(should_apply : boolean) : void
    }

    declare class Interpreter {
        parent? : multis.Universe
        states : Array<multis.State>

        // events : any[]
        // ops : any[]
        // imods : any[]
        

        initCell(pos : p5.Vector, ops : any, store : multis.Universe) : void
        init() : void
        step() : void
        reset() : void
        
        value(x : number, y : number, velx : number, vely : number) : multis.State
        specific(position : p5.Vector) : void
        regs(pos : p5.Vector, op : opcode) : void

        inspect(x : number, y : number, tx : number, ty : number) : void
        inspection() : void
    }

    declare class Universe {
        interpreter : multis.Interpreter
        width : number
        height : number
        cells? : opcode[][]

        reset(width : number, height : number) : void
        set(x : number, y : number, op : opcode) : void
        empty() : void
        json(input? : string|object, clear? : boolean) : string?
    }
}

declare namespace editor {
    declare type PrefabContent = Array<{ op : string, x : number, y : number }>;
    declare class Prefab {
        name : string
        width : number
        height : number

        content : PrefabContent


        instantiate() : void
    }

    declare class Selector implements p5.Event {
        opindex : number

        // constructor(onpaint : any, width : number, height : number, canvas : any)
        constructor()


        setup() : void
        draw() : void
        
        getAction() : multis.opcode
        action(store : multis.Universe, x : number, y : number) : void
    }

    declare class PrefabSelector extends Selector {
        prefab : Prefab

        getAction() : PrefabContent
    }

    declare class Canvas {
        width : number;
        height : number;
        // p5 : any
        // canvas : any;
        // onpaint : any;
        
        constructor(paintfn : CallbackFunction, canvas : p5.Canvas, initfn? : CallbackFunction)
        constructor(paintfn : CallbackFunction, width : number, height : number, canvas : p5.Canvas, initfn? : CallbackFunction)
    
        repaint() : void
        // draw_fn() : void // --> should not be called
        draw() : void
        draw(x : number, y : number) : void
    }


    declare class Logger {
        constructor(query : string);

        data(msg : string, color : string, br? : boolean) : void
        print() : void
        clear() : void

        throw(error : Error) : void
    }


    declare var prefabs : Array<Prefab>;
    // static editor variables
    declare var stdout : Logger;
}

// editor variables
declare var selector : editor.PrefabSelector | editor.Selector;

// main variables
declare var interp : multis.Interpreter;
declare var store : multis.Universe;